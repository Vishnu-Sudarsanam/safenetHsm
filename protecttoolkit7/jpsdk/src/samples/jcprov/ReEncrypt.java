import java.nio.charset.*;
import java.util.*;

import safenet.jcprov.*;
import safenet.jcprov.constants.*;

/**
 * This class demonstrates re-encryption of variable length data.
 * <p>
 * Re-encryption is where cipher text (encrypted key or data) is decrypted
 * with one key, and then the resulting plain text is encrypted with another
 * key. Typically you want this operation to occur in such a way as to avoid
 * the intermediate plain text from leaving the security of the adapter.
 * <p>
 * This is achieved in PKCS#11 via the C_UnwrapKey and C_WrapKey functions. By
 * specifying the intermediate plain text data as a GENERIC_SECRET, SENSITIVE,
 * Session object, you can keep variable length data securely in the adapter.
 * <p>
 * This program assumes that slot 0 exists. All objects generated during program
 * execution are session objects, and as such the contents of the token in
 * slot 0 are not modified.
 * <p>
 * Usage : java ...samples.ReEncrypt
 */
public class ReEncrypt
{

    /** easy access to System.out.println */
    static public void println(String s)
    {
        System.out.println(s);
    }

    /** main execution method */
    public static void main(String[] args)
    {
        CK_SESSION_HANDLE session = new CK_SESSION_HANDLE();
        long slotId = 0;

        /*
         * This sample is going to generate all the wrapping and unwrapping
         * keys as triple DES session objects.
         *
         * This just makes it easier to run - you don't have to set up the keys
         * before hand :-).
         */

        try
        {
            /*
             * Initialize Cprov so that the library takes care
             * of multithread locking
             */
            CryptokiEx.C_Initialize(new CK_C_INITIALIZE_ARGS(CKF.OS_LOCKING_OK));

            /*
             * Open a session
             */
            CryptokiEx.C_OpenSession(slotId, CKF.RW_SESSION, null, null, session);

            /*
             * Generate the keys we need.
             *
             * Conceptually, we need :-
             *
             *  Original Encryption Key
             *      This key is used to encrypt the original plain text. This key
             *      could be one half of a key pair (e.g. the public portion of an
             *      RSA key pair). In this sample, we are using a symetric key.
             *
             *  Unwrap Key
             *      This key is used to unwrap the cipher text into a GENERIC_SECRET.
             *      This key must be related to the Original Encryption Key (e.g.
             *      the private portion of an RSA key pair). In this sample, we are using
             *      a symetric key, so this key is the Original Encryption Key.
             *
             *  Wrap Key
             *      This key is used to wrap (or re-encrypt) the intermediate plain text
             *      derived by the Unwrap Key. This key could be one half of a key pair
             *      (e.g. the public portion of an RSA key pair). In this sample, we are using
             *      a symetric key.
             *
             *  Decryption Key
             *      This key is used to decrypt the cipher text generated by the Wrap Key
             *      (the re-encryption key), so it must be related to the Wrap Key (e.g.
             *      the private portion of an RSA key pair). In this sample, we are using
             *      a symetric key, so this key is the Wrap Key.
             */

            /*
             * Generate the Original Encryption Key - used to encrypt the original plain text
             */
            CK_OBJECT_HANDLE hEncryptionKey = GenerateKey(session);

            /*
             * Because we are using symetric keys, the Unwrap Key must be the Original
             * Encryption Key
             */
            CK_OBJECT_HANDLE hUnwrapKey = hEncryptionKey;

            /*
             * Generate the Wrap Key - used to wrap (re-encrypt) the intermediate
             * plain text.
             */
            CK_OBJECT_HANDLE hWrapKey = GenerateKey(session);

            /*
             * Because we are using symetric keys, the Decryption Key must be the
             * Unwrap Key.
             */
            CK_OBJECT_HANDLE hDecryptionKey = hWrapKey;

            /*
             * Now, encrypt some original text.
             *
             * Note that the length of the original text is not a multiple of
             * the encryption block size (in this case 8), so we need to use
             * a padding mechanism.
             */
            String originalText = "not block multiple";
            CK_MECHANISM encryptionMechanism = new CK_MECHANISM(CKM.DES3_ECB_PAD);

            byte[] plainData = originalText.getBytes(StandardCharsets.US_ASCII);
            byte[] cipherData = null;
            LongRef lRef = new LongRef();

            /* initialise the operation */
            CryptokiEx.C_EncryptInit(session, encryptionMechanism, hEncryptionKey);

            /*
             * determine the length of the resulting cipher text
             *
             * Note that this is just a prediction, only guaranteed to be big enough.
             */
            CryptokiEx.C_Encrypt(session,
                                 plainData, plainData.length,
                                 null, lRef);

            /* allocate space for the cipher text */
            cipherData = new byte[(int)lRef.value];

            /* encrypt the plain text */
            CryptokiEx.C_Encrypt(session,
                                 plainData, plainData.length,
                                 cipherData, lRef);

            println("original:" + bytesToHexString(plainData));

            /* truncate result to 'true' length */
            cipherData = extractLeft(cipherData, lRef.value);

            println("cipher1 :" + bytesToHexString(cipherData));

            /*
             * Now we have some cipher text.
             *
             * Re-encrypt it. This operation has been isolated in a
             * function because it is the heart of the example :-)
             */

            /* mechanism for unwrapping the data - this is related to how it was encrypted */
            CK_MECHANISM unwrapMechanism = new CK_MECHANISM(CKM.DES3_ECB_PAD);

            /* mechanism for wrapping the data - this is related to how if will be decrypted */
            CK_MECHANISM wrapMechanism = new CK_MECHANISM(CKM.DES3_ECB_PAD);

            byte[] reEncryptedCipherData = null;

            reEncryptedCipherData = doReEncrypt(session,
                                              hUnwrapKey, unwrapMechanism,
                                              cipherData,
                                              plainData.length,
                                              hWrapKey, wrapMechanism);

            println("cipher2 :" + bytesToHexString(reEncryptedCipherData));

            /*
             * To test that it all worked, decrypted the new cipher text
             * and compare it to the original plain text
             */
            CK_MECHANISM decryptionMechanism = new CK_MECHANISM(CKM.DES3_ECB_PAD);
            byte[] newPlainData = null;

            /* initialise the operation */
            CryptokiEx.C_DecryptInit(session, decryptionMechanism, hDecryptionKey);

            /* determine the length of the resulting plain text - prediction only */
            lRef.value = 0;
            CryptokiEx.C_Decrypt(session,
                                 reEncryptedCipherData, reEncryptedCipherData.length,
                                 null, lRef);

            /* allocate space */
            newPlainData = new byte[(int)lRef.value];

            /* decrypt the data */
            CryptokiEx.C_Decrypt(session,
                                 reEncryptedCipherData, reEncryptedCipherData.length,
                                 newPlainData, lRef);

            newPlainData = extractLeft(newPlainData, lRef.value);
            println("plain2  :" + bytesToHexString(newPlainData));

            /*
             * Compare.
             */
            String szNewPlainData = new String(newPlainData, StandardCharsets.US_ASCII);

            if (originalText.equals(szNewPlainData))
            {
                println("Hurray, re-encryption worked :-)");
            }
            else
            {
                println("Something went very wrong :-(");
            }
        }
        catch (CKR_Exception ex)
        {
            /*
             * A Cryptoki related exception was thrown
             */
            ex.printStackTrace();
        }
        catch (Exception ex)
        {
            ex.printStackTrace();
        }
        finally
        {
            /*
             * Close the session.
             *
             * Note that we are not using CryptokiEx and we are not checking the
             * return value. This is because if we did not open the session then an error
             * will be reported - and we don't really care because we are shutting down.
             */
            Cryptoki.C_CloseSession(session);

            /*
             * All done with Cryptoki
             *
             * Note that we are not using CryptokiEx.
             */
             Cryptoki.C_Finalize(null);
        }
    }

    /**
     * Generate a triple DES key usable for Encryption, Decryption, Wrapping and Unwrapping.
     *
     * @param session
     *  handle to an open session
     */
    static CK_OBJECT_HANDLE GenerateKey(CK_SESSION_HANDLE session)
    {
        /* template for the desired session key */
        CK_ATTRIBUTE[] template =
        {
            /* we only want session keys */
            new CK_ATTRIBUTE(CKA.TOKEN,     CK_BBOOL.FALSE),

            /* we want keys that can do everything */
            new CK_ATTRIBUTE(CKA.ENCRYPT,   CK_BBOOL.TRUE),
            new CK_ATTRIBUTE(CKA.DECRYPT,   CK_BBOOL.TRUE),
            new CK_ATTRIBUTE(CKA.WRAP,      CK_BBOOL.TRUE),
            new CK_ATTRIBUTE(CKA.UNWRAP,    CK_BBOOL.TRUE)
        };

        /* we want to generate a triple DES key */
        CK_MECHANISM mechanism = new CK_MECHANISM(CKM.DES3_KEY_GEN);

        /* resulting key handle */
        CK_OBJECT_HANDLE hKey = new CK_OBJECT_HANDLE();

        CryptokiEx.C_GenerateKey(session, mechanism, template, template.length, hKey);

        return hKey;
    }

    /**
     * Re-encrypt the passed in cipher data by unwrapping it into a GENERIC_SECRET
     * and then re-wrapping it.
     *
     * @param session
     *  handle to an open session
     *
     * @param hUnwrapKey
     *  handle to the key to use for unwrapping
     *
     * @param unwrapMechanism
     *  mechanism to use for unwrapping the cipher data
     *
     * @param cipherData
     *  the data to re-encrypt
     *
     * @param hWrapKey
     *  handle to the key to use for wrapping (re-encryption)
     *
     * @param wrapMechanism
     *  mechanism to use to wrap (re-encrypt) the intermediate plain text
     */
    static byte[] doReEncrypt(CK_SESSION_HANDLE session,
                              CK_OBJECT_HANDLE hUnwrapKey,
                              CK_MECHANISM unwrapMechanism,
                              byte[] cipherData,
                              long plainTextLength,
                              CK_OBJECT_HANDLE hWrapKey,
                              CK_MECHANISM wrapMechanism)
    {
        /*
         * Template for the intermediate data.
         */
        CK_ATTRIBUTE[] template =
        {
            /* make it a variable length 'key' */
            new CK_ATTRIBUTE(CKA.CLASS,         CKO.SECRET_KEY),
            new CK_ATTRIBUTE(CKA.KEY_TYPE,      CKK.GENERIC_SECRET),

            /* not retrievable from the adapter in the clear */
            new CK_ATTRIBUTE(CKA.SENSITIVE,     CK_BBOOL.TRUE),

            /* we want to re-wrap the value */
            new CK_ATTRIBUTE(CKA.EXTRACTABLE,   CK_BBOOL.TRUE),

            /* make the intermediate 'key' unusable for cipher operations */
            new CK_ATTRIBUTE(CKA.ENCRYPT,       CK_BBOOL.FALSE),
            new CK_ATTRIBUTE(CKA.DECRYPT,       CK_BBOOL.FALSE),
            new CK_ATTRIBUTE(CKA.WRAP,          CK_BBOOL.FALSE),
            new CK_ATTRIBUTE(CKA.UNWRAP,        CK_BBOOL.FALSE),

            /* make it a temporary session object */
            new CK_ATTRIBUTE(CKA.TOKEN,         CK_BBOOL.FALSE),

            /* set the length of the data */
            new CK_ATTRIBUTE(CKA.VALUE_LEN,     plainTextLength),
        };

        CK_OBJECT_HANDLE hIntermediateKey = new CK_OBJECT_HANDLE();
        byte[] reEncryptedData = null;
        LongRef lRef = new LongRef();

        /* unwrap (decrypt) the data */
        CryptokiEx.C_UnwrapKey(session,
                               unwrapMechanism, hUnwrapKey,
                               cipherData, cipherData.length,
                               template, template.length,
                               hIntermediateKey);

        /* determine size of re-encrypted data */
        CryptokiEx.C_WrapKey(session,
                             wrapMechanism, hWrapKey,
                             hIntermediateKey,
                             null, lRef);

        /* allocate space */
        reEncryptedData = new byte[(int)lRef.value];

        /* wrap (re-encrypt) the data */
        CryptokiEx.C_WrapKey(session,
                             wrapMechanism, hWrapKey,
                             hIntermediateKey,
                             reEncryptedData, lRef);

        reEncryptedData = extractLeft(reEncryptedData, lRef.value);

        /* destroy the intermediate clear data */
        CryptokiEx.C_DestroyObject(session, hIntermediateKey);

        return reEncryptedData;
    }

    /**
     * Extract the specified number of bytes from the left of the input buffer.
     *
     * @param data
     *  buffer to extract from
     *
     * @param num
     *  number of bytes to take from the left of data
     */
    static byte[] extractLeft(byte[] data, long num)
    {
        if (num >= data.length)
        {
            return data;
        }
        else
        {
            return Arrays.copyOf(data, (int)num);
        }
    }

    /**
     * Convert a byte array to a hex string.
     *
     * Each byte of the input is convert into two hex characters. There is no
     * space added between the character pairs.
     *
     * @param data
     *  hex data to convert
     */
    static String bytesToHexString(byte[] data)
    {
        final String hexCodes = "0123456789ABCDEF";

        int len = data.length;

        char[] ret = new char[len * 2];

        byte digit;
        int j = 0;

        for (int i = 0; i < len; ++i)
        {
            // mask & get the first 4 bits of the byte
            digit = (byte) ((data[i] & 0xF0l) >>> 4);

            // convert to hex
            ret[j++] = hexCodes.charAt(digit);

            // mask & get the last 4 bits of the byte
            digit = (byte) (data[i] & 0x0Fl);

            // convert to hex
            ret[j++] = hexCodes.charAt(digit);
        }

        return (new String(ret));
    }
}
